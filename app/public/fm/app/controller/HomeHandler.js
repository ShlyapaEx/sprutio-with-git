// Generated by CoffeeScript 1.11.1
Ext.define('FM.controller.HomeHandler', {
  extend: 'Ext.app.Controller',
  views: [],
  init: function() {
    FM.Logger.log('HomeHandler init!');
    return this.listen({
      controller: {
        '*': {
          eventHomeInitCallback: 'homeInitCallback',
          eventHomeProcessInit: 'processInit'
        }
      }
    });
  },
  onLaunch: function() {},
  homeInitCallback: function(panels) {
    FM.Logger.log('Event homeInitCallback run in HomeHandler! panels = ', panels);
    return FM.backend.ajaxSend('/actions/home/init_callback', {
      success: (function(_this) {
        return function(response) {
          var response_data;
          response_data = Ext.util.JSON.decode(response.responseText).data;
          return _this.fireEvent(FM.Events.home.processInit, response_data, panels);
        };
      })(this)
    });
  },
  processInit: function(data, panels) {
    FM.Logger.log('Event processInit run in HomeHandler! data = ', data, panels);
    FM.Home = {};
    FM.Home.connections = [];
    FM.Home.webdav_connections = [];
    if (data.quota != null) {
      FM.Home.quota = data.quota;
      this.processQuota(data.quota, panels);
    }
    if (data.connections != null) {
      FM.Home.connections = [];
      this.processConnections(data.connections);
    }
    if (data.account != null) {
      FM.Home.account = data.account;
      this.processAccount(data.account, panels);
    }
    if (data.webdav_connections != null) {
      FM.Home.webdav_connections = [];
      this.processWebDavConnections(data.webdav_connections);
    }
    return this.processFastMenu(data, panels);
  },
  processFastMenu: function(data, panels) {
    var i, len, panel, results;
    FM.Logger.log('processFastMenu() called arguments =', arguments);
    results = [];
    for (i = 0, len = panels.length; i < len; i++) {
      panel = panels[i];
      results.push((function(panel) {
        var connection, connection_menu, fast_menu, fn, home_menu, j, l, len1, len2, menu_element, ref, ref1, webdav_connection_menu, webdav_menu_element;
        fast_menu = {
          xtype: 'menu',
          items: []
        };
        home_menu = {
          xtype: 'menuitem',
          text: FM.Actions.HomeFtp.getMenuText(),
          iconCls: FM.Actions.HomeFtp.getIconCls(),
          handler: (function(_this) {
            return function() {
              return FM.Actions.HomeFtp.execute(panel);
            };
          })(this)
        };
        fast_menu.items.push(home_menu);
        if ((data.connections != null) && data.connections.length > 0) {
          menu_element = {
            xtype: 'menuitem',
            text: FM.Actions.RemoteConnections.getMenuText(),
            iconCls: FM.Actions.RemoteConnections.getIconCls(),
            handler: (function(_this) {
              return function() {
                return FM.Actions.RemoteConnections.execute();
              };
            })(this)
          };
          connection_menu = [];
          if (data.connections.length <= 100) {
            ref = data.connections;
            for (j = 0, len1 = ref.length; j < len1; j++) {
              connection = ref[j];
              if (connection.type === 'sftp') {
                (function(connection) {
                  var connection_menu_element;
                  connection_menu_element = {
                    xtype: 'menuitem',
                    text: connection.user + "@" + connection.host,
                    iconCls: 'fm-action-connect-ftp',
                    handler: (function(_this) {
                      return function() {
                        var server_id;
                        server_id = parseInt(connection.id.replace(/(sf|f)tp/, ''));
                        return FM.Actions.OpenRemoteConnection.execute(panel, {
                          type: FM.Session.SFTP,
                          path: '.',
                          server_id: server_id
                        });
                      };
                    })(this)
                  };
                  return connection_menu.push(connection_menu_element);
                })(connection);
              }
              if (connection.type === 'ftp') {
                (function(connection) {
                  var connection_menu_element;
                  connection_menu_element = {
                    xtype: 'menuitem',
                    text: connection.user + "@" + connection.host,
                    iconCls: 'fm-action-connect-ftp',
                    handler: (function(_this) {
                      return function() {
                        var server_id;
                        server_id = parseInt(connection.id.replace(/(sf|f)tp/, ''));
                        return FM.Actions.OpenRemoteConnection.execute(panel, {
                          type: FM.Session.FTP,
                          path: '/',
                          server_id: server_id
                        });
                      };
                    })(this)
                  };
                  return connection_menu.push(connection_menu_element);
                })(connection);
              }
            }
          }
          if (connection_menu.length > 0) {
            menu_element.menu = connection_menu;
          }
          fast_menu.items.push(menu_element);
        }
        if ((data.webdav_connections != null) && data.webdav_connections.length > 0) {
          webdav_menu_element = {
            xtype: 'menuitem',
            text: FM.Actions.RemoteWebDav.getMenuText(),
            iconCls: FM.Actions.RemoteWebDav.getIconCls(),
            handler: (function(_this) {
              return function() {
                return FM.Actions.RemoteWebDav.execute();
              };
            })(this)
          };
          webdav_connection_menu = [];
          if (data.webdav_connections.length <= 100) {
            ref1 = data.webdav_connections;
            fn = function(connection) {
              var webdav_connection_menu_element;
              webdav_connection_menu_element = {
                xtype: 'menuitem',
                text: connection.user + "@" + connection.host,
                iconCls: 'fm-action-connect-webdav',
                handler: (function(_this) {
                  return function() {
                    return FM.Actions.OpenWebDav.execute(panel, {
                      type: FM.Session.WEBDAV,
                      path: '/',
                      server_id: connection.id
                    });
                  };
                })(this)
              };
              return webdav_connection_menu.push(webdav_connection_menu_element);
            };
            for (l = 0, len2 = ref1.length; l < len2; l++) {
              connection = ref1[l];
              fn(connection);
            }
          }
          if (webdav_connection_menu.length > 0) {
            webdav_menu_element.menu = webdav_connection_menu;
          }
          fast_menu.items.push(webdav_menu_element);
        }
        return panel.setFastMenu(fast_menu);
      })(panel));
    }
    return results;
  },
  processAccount: function(account, panels) {
    var host, i, len, login, panel, results, server_name, session_data, type;
    login = account.login != null ? account.login : '';
    server_name = account.server != null ? account.server : '';
    results = [];
    for (i = 0, len = panels.length; i < len; i++) {
      panel = panels[i];
      if (panel.session.type === FM.Session.HOME) {
        results.push(panel.setServerName(login + '@' + server_name));
      } else {
        session_data = FM.Stores.Conenctions.getById(panel.session.type + panel.session.server_id).data;
        login = session_data.user;
        type = session_data.type;
        host = session_data.host;
        results.push(panel.setServerName(type + '://' + login + '@' + host));
      }
    }
    return results;
  },
  processConnections: function(connections) {
    var i, k, len, v;
    FM.Logger.log('processConnections() called arguments =', arguments);
    for (k = i = 0, len = connections.length; i < len; k = ++i) {
      v = connections[k];
      connections[k]['id'] = v['type'] + v['id'];
    }
    return FM.Stores.Conenctions.loadData(connections);
  },
  processWebDavConnections: function(webdav_connections) {
    FM.Logger.log('processConnections() called arguments =', arguments);
    return FM.Stores.WebDavConenctions.loadData(webdav_connections);
  },
  processQuota: function(quota, panels) {
    var all, all_files, file_quota, free, i, len, panel, percent, rounded, rounded_all, rounded_all_files, rounded_files, text, used, used_files, warning;
    FM.Logger.log('processQuota() called arguments =', arguments);
    used = parseInt(quota.blockUsed) / 1024;
    all = parseInt(quota.blockHard) / 1024;
    used_files = parseInt(quota.FileUsed) / 1000;
    all_files = parseInt(quota.FileHard) / 1000;
    free = (all - used) / 1024;
    rounded = (used / 1024).toFixed(2);
    rounded_all = (all / 1000).toFixed(2);
    rounded_files = (used_files / 1000).toFixed(2);
    rounded_all_files = (all_files / 1000).toFixed(2);
    file_quota = false;
    percent = used / all;
    if (all_files !== 0 && all !== 0) {
      if ((used_files / all_files) > (used / all)) {
        file_quota = true;
        percent = used_files / all_files;
      }
    }
    if (all === 0) {
      text = "Без ограничений";
      percent = 0;
    } else if (file_quota) {
      text = "Занято " + rounded_files + "k " + rounded_all_files + "k файлов";
    } else {
      text = "Занято " + rounded + "Гб / " + rounded_all + "Гб";
    }
    warning = false;
    for (i = 0, len = panels.length; i < len; i++) {
      panel = panels[i];
      if (panel.session.type === FM.Session.HOME) {
        panel.setQuota(true, percent, text);
        if (percent > FM.Quota.WARNING_PERCENT) {
          warning = true;
        }
      } else {
        panel.setQuota(false);
      }
    }
    if (warning) {
      if (file_quota) {
        return FM.helpers.ShowWarning(t("Your file quota is almost full. <br/>For this reason some file operations may not work."));
      } else {
        return FM.helpers.ShowWarning(t("Your account quota is almost full. <br/>For this reason some file operations may not work."));
      }
    }
  }
});
